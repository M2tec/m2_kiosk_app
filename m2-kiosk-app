#!/bin/python3

import argparse
import gi
import json
import subprocess
import requests

import secrets
import string

from datetime import datetime

from cardano.wallet import Wallet
from cardano.wallet import WalletService

from cardano.backends.walletrest import WalletREST

from m2_paypad_dbus import *

gi.require_version("Gtk", "3.0")
from gi.repository import Gio, GLib, Gtk, GdkPixbuf

ws = WalletService(WalletREST(port=8090))

def is_port_in_use(port):
    import socket
    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
        return s.connect_ex(('localhost', port)) == 0


# Handle command line arguments
parser = argparse.ArgumentParser(description='M2 Kiosk App for processing blockchain payments.')
parser.add_argument('-p', '--odoo-port', help='specify Odoo port number')
args = parser.parse_args(['--odoo-port', '8069'])

odoo_port = args.odoo_port
wallet_port = 8090

# Thanks to  Gio test files at GNOME repo: glib/blob/master/gio/tests/gdbus-example-server.c
# Generating interface from XML is easy. Look at the above file on how it is done.
# A better resource : http://maemo.org/maemo_training_material/maemo4.x/html/
#                     maemo_Platform_Development_Chinook/
#                     Chapter_03_Using_the_GLib_wrappers_for_DBus.html
#                     #DBusinterfacedefinitionusingXML



xml = (
    "<node>"
    "  <interface name='org.m2tec.paypad'>"
    "    <method name='PollAlive'>"
    "      <arg type='s' name='msg' direction='in'/>"
    "      <arg type='s' name='serviceId' direction='out'/>"
    "    </method>"
    "    <method name='SetPayment'>"
    "      <arg type='s' name='transactionId' direction='in'/>"
    "      <arg type='s' name='walletAddress' direction='in'/>"
    "      <arg type='s' name='payAmount' direction='in'/>"
    "      <arg type='s' name='ServiceId' direction='in'/>"
    "      <arg type='s' name='greeting' direction='out'/>"
    "    </method>"
    "    <method name='Quit'/>"
    "  </interface>"
    "</node>"
)

node = Gio.DBusNodeInfo.new_for_xml(xml)  # We make a node for the xml
#loop = GLib.MainLoop() # A loop to handle API

builder = Gtk.Builder()
builder.add_from_file("paypad.glade")
amount_label = builder.get_object("amount_label")
window1 = builder.get_object("window1")

headerbar = Gtk.HeaderBar()
headerbar.set_title("M2 PayPad")
headerbar.set_show_close_button(False)
window1.set_titlebar(headerbar)

#window1.set_show_close_button(False)
image1 = builder.get_object("image1")
pixbuf = GdkPixbuf.Pixbuf.new_from_file('./static/default.png')
pixbuf = pixbuf.scale_simple(380, 380, GdkPixbuf.InterpType.BILINEAR)
image1.set_from_pixbuf(pixbuf)   

def transactions(wallet_id, transaction_id):
    wal0 = Wallet(wallet_id, backend=WalletREST(port=wallet_port))
    wal0.sync_progress()
    
    wallet_balance = wal0.balance().total
    #print(wal0.balance().total)
    
    tnxs = wal0.transactions()
    
    transact = []
    
    result = "OK"
    
    for tnx in tnxs:
        tnx_dict = {'id': tnx.txid, 'fee': tnx.fee, 'input': tnx.amount_in, 'output': tnx.amount_out, 'metadata': tnx.metadata, 'status' : tnx.status}
        
        #print(dir(tnx))
        #print(json.dumps(tnx, indent=4, sort_keys=False))
        #print(repr(tnx_dict))
        #print("\n")
        #transact.append(tnx_dict)   
        
        metadata = tnx.metadata
        #print(metadata.keys())
        
        tx_id = ''
        
        try:
            tx_id = metadata[73]['title']
            #print('tx_id: ' + str(tx_id))
        except KeyError:
            pass
    
        #print("tx_id = " + tx_id + " and transaction_id = " + transaction_id)
        if tx_id != '' and tx_id == transaction_id:
            print("success")
            result = "success"          
            
    return result

def confirm_payment(service_id):
    TIMEOUT = 10
    endpoint = 'http://localhost:' + odoo_port + '/pos_cardano/notification'
    
    headers = {
        'Content-Type': 'application/json'
    }

    confirmation_data = {
        "SaleToPOIResponse": {"PaymentResponse": {"Response": { "Result" : "Success"}, "PaymentResult" : { "AmountsResp" : "-",  "AmountsResp" : "-"} },
                              "MessageHeader": {"MessageCategory": "Payment",
                                                "MessageClass": "Service",
                                                "MessageType": "Response",
                                                "POIID": "Terminal1",
                                                "ProtocolVersion": "3.0",
                                                "SaleID": "x",
                                                "ServiceID": service_id}}}
    request_odoo = requests.post(endpoint, data=json.dumps(confirmation_data), headers=headers, timeout=TIMEOUT) 

class Runner:
    def __init__(self, num_times):
        self.num_times = num_times
        self.count = 0

    def __call__(self, *args):
        transaction_id = args[0]
        service_id = args[1]
        wallet_id = args[2]
                        
        result = transactions(wallet_id, transaction_id)
        
        print("result = "  + result )
        if result == "success":
            print("go to confirm payment")
            confirm_payment(service_id)
            self.count = self.num_times
            
        self.count += 1
        print("Periodic timer [{}]: args={}".format(self.count, args))
        
        return self.count < self.num_times

check_blockchain = Runner(100)

def create_transaction_json(transaction_id, wallet_address, amount):


    print('shop code: ' + transaction_id + str(wallet_address) + str(amount))
    metadata_dict = {
        '123': {'message': transaction_id}
    }
        
    amounts_dict_1 = {
        'quantity': str(int(amount * 1000000)), 
        'policyId': 'ada', 
        'assetName': 'ada'
    }
    
    amounts_list = [ amounts_dict_1 ]
    
    outputs_dict = { 
        wallet_address : amounts_list
    }

    transaction_dict = {
        'type': 'tx', 
        'title': transaction_id, 
        'outputs': outputs_dict,
    }

    print(json.dumps(transaction_dict, indent=4, sort_keys=True))
    
    return json.dumps(transaction_dict)

def create_qr_code(transaction_id, wallet_address, amount ):

    tx_json = create_transaction_json(transaction_id, wallet_address, amount)
   
    filename_qr_code = 'static/shop_qr_code-' + transaction_id + '.png'
    print(filename_qr_code)    
    
    cardano_net = 'testnet'    
    gc_cli = '/home/maarten/cardano-src/m2_kiosk_app/node_modules/gamechanger-dapp-cli/cli.js'
    command_list = [gc_cli, cardano_net, 'build', 'qr', '-a', tx_json, '-o', filename_qr_code]
    result = subprocess.run(command_list, stdout=subprocess.PIPE)

def handle_method_call(
    connection, sender, object_path, interface_name, method_name, params, invocation
):
    """
    This is the top-level function that handles all the method calls to our server.
    The first four parameters are self-explanatory.
    `method_name` is a string that describes our method name.
    `params` is a GLib.Variant that are inputs/parameters to the method.
    `invocation` is a Gio.DBusMethodInvocation, something like a messenger that transports
    our reply back to sender.
    """

    print("CALLED")
    # We need to unpack GLib.Variant to a Python object. The unpacked one is always a
    # tuple.
    if method_name == "PollAlive":
        msg = params.unpack()[0]  # First argument is what we need
        print(f"FROM {sender} : {msg}")
        
        now = datetime.now()
        dt_string = now.strftime("%Y-%m-%d-%H-%M-%S")
        #print("date and time =", dt_string)	        
                
        service_id = GLib.Variant("(s)", (f"sID-{dt_string}",))
        invocation.return_value(service_id)  # Nothing to say, so just return None.

        # Send the answer as a http request to Odoo
        TIMEOUT = 10
        endpoint = 'http://localhost:' + odoo_port + '/pos_cardano/notification'
        
        headers = {
            'Content-Type': 'application/json'
        }    
           
        diagnosis_data = {        
                "SaleToPOIResponse": {"DiagnosisResponse": {"HostDiagnosisFlag": False},
                              "MessageHeader": {"MessageCategory": "Diagnosis",
                                                "MessageClass": "Service",
                                                "MessageType": "Response",
                                                "POIID": "Terminal1",
                                                "ProtocolVersion": "3.0",
                                                "SaleID": "Shop (Mitchell Admin) (ID: "
                                                          "1)",
                                                "ServiceID": "sID-" + dt_string }}}
        
        request_odoo = requests.post(endpoint, data=json.dumps(diagnosis_data), headers=headers, timeout=TIMEOUT)    


    elif method_name == "SetPayment":
        transaction_id = params.unpack()[0]
        wallet_id = params.unpack()[1]
        pay_amount = float(params.unpack()[2])
        service_id = params.unpack()[3]
        
        print(f"FROM {sender} : CONFIRMED {pay_amount}")
        greeting = GLib.Variant(
            "(s)", (f"Amount set to: {pay_amount}",)
        )  # All form of return should be a
        # variant.
        invocation.return_value(greeting)

        wallet = Wallet(wallet_id, backend=WalletREST(port=8090))
        wallet_address = str(wallet.first_unused_address())
        print(wallet_address)
        
        create_qr_code(transaction_id, wallet_address, pay_amount)
        
        qr_code_file_name = 'static/shop_qr_code-' + transaction_id + '.png'
        pixbuf = GdkPixbuf.Pixbuf.new_from_file(qr_code_file_name)
        pixbuf = pixbuf.scale_simple(380, 380, GdkPixbuf.InterpType.BILINEAR)
        image1.set_from_pixbuf(pixbuf)   

        amount_label.set_text("{:.2f}".format(pay_amount))         
        
        check_blockchain.count = 0
        print(transaction_id + ' ' + service_id)
        GLib.timeout_add(5000, check_blockchain, transaction_id, service_id, wallet_id)   

    elif method_name == "Quit":
        loop.quit()
        invocation.return_value(None)


if __name__ == "__main__":

    # Check if Odoo is running
    if is_port_in_use(int(odoo_port)):
        print("Connecting to Odoo on port: " + str(odoo_port))
    else:
        print("Make sure Odoo is running on port: " + str(odoo_port))
        quit()

    # Check if Cardano wallet backend is running
    if is_port_in_use(int(wallet_port)):
        print("Connecting to Cardano wallet backend on port: " + str(wallet_port))
    else:
        print("Make sure the Cardano wallet backend is running on port: " + str(wallet_port))
        quit()

    # Check if cardano wallet backend is running
    command_list = ['cardano-wallet', 'wallet', 'list']
    process = subprocess.Popen(command_list, 
                              stdout=subprocess.PIPE,
                              stderr=subprocess.PIPE,
                              universal_newlines=True)
     
    stdout = process.stdout.readline()
    stderr = process.stderr.readline()

    wallets = ws.wallets()

    if not stderr.startswith('Ok'):
        print('Are you sure the Cardano wallet backend is running')
        print(stderr)
    else:
        if not wallets:
            print('There are no wallets defined')
            print('Creating a new wallet')
            print('WARNING: Recovery phrase and password is saved in mnemonic.txt store in a safe place!!!!')
            
            # Gererate a mnemonic   
            command_list = ['cardano-wallet', 'recovery-phrase', 'generate']
            process = subprocess.Popen(command_list, 
                              stdout=subprocess.PIPE,
                              stderr=subprocess.PIPE,
                              universal_newlines=True)            
            mnemonic = process.stdout.readline()
                       
            # Generate a password for a new wallet
            alphabet = string.ascii_letters + string.digits
            password = ''.join(secrets.choice(alphabet) for i in range(10))  # for a 20-character password

            print(mnemonic)
            print(password)

            # Save the mnemonic to a file
            f = open("mnemonic.txt", "a")
            f.write(mnemonic)
            f.write(password)
            f.close()
            
            wal = ws.create_wallet(
                name="Odoo shop wallet",
                mnemonic=mnemonic,
                passphrase=password,
                ) 
                
        print('\nThe following wallets are available listed by id:')
        for wallet in wallets:
            print(wallet.wid)
    
    # Start a system message bus for the paypad
    owner_id = Gio.bus_own_name(
        Gio.BusType.SYSTEM,  
        "org.m2tec.paypad",  
        Gio.BusNameOwnerFlags.NONE,  
        on_bus_acquired,
        on_name_acquired,
        on_name_lost,
    )
    
    window1.show_all()

    Gtk.main() 
    Gio.bus_unown_name(owner_id)
    print("Exiting...")

